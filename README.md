<p align="center">
	<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KICAgIDxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgODAwIDIwMCI+CiAgICAgICAgPGRlZnM+CiAgICAgICAgICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYmctZ3JhZGllbnQiIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMTAwJSIgeTI9IjEwMCUiPgogICAgICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzQxNThEMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iNTAlIiBzdHlsZT0ic3RvcC1jb2xvcjojQzg1MEMwO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojRkZDQzcwO3N0b3Atb3BhY2l0eToxIiAvPgogICAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgICAgICAgICA8ZmlsdGVyIGlkPSJzaGFkb3ciPgogICAgICAgICAgICAgICAgPGZlRHJvcFNoYWRvdyBkeD0iMCIgZHk9IjQiIHN0ZERldmlhdGlvbj0iNCIgZmxvb2Qtb3BhY2l0eT0iMC4yNSIgLz4KICAgICAgICAgICAgPC9maWx0ZXI+CiAgICAgICAgPC9kZWZzPgogICAgICAgIDxyZWN0IHdpZHRoPSI4MDAiIGhlaWdodD0iMjAwIiBmaWxsPSJ1cmwoI2JnLWdyYWRpZW50KSIgcng9IjE1IiByeT0iMTUiLz4KICAgICAgICA8dGV4dCB4PSI0MDAiIHk9IjEwMCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjQ4IgogICAgICAgIGZvbnQtd2VpZ2h0PSJib2xkIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIgogICAgICAgIGZpbGw9IiNGRkZGRkYiIGZpbHRlcj0idXJsKCNzaGFkb3cpIj5QWVRIT04tU0NSSVBUPC90ZXh0PgogICAgPC9zdmc+" alt="python-script-banner" width="800">
</p>
<br>
<p align="center">
	<em><code>Script Python Utili. Gli script sono testati personalmente ed utilizzati giornalmente.</code></em>
</p>
<br>
<p align="center">
	<img src="https://img.shields.io/github/license/Magnetarman/Python-Script?style=flat&logo=opensourceinitiative&logoColor=white&color=0080ff" alt="license">
	<img src="https://img.shields.io/github/last-commit/Magnetarman/Python-Script?style=flat&logo=git&logoColor=white&color=0080ff" alt="last-commit">
	<img src="https://img.shields.io/github/languages/top/Magnetarman/Python-Script?style=flat&color=0080ff" alt="repo-top-language">
	<img src="https://img.shields.io/github/languages/count/Magnetarman/Python-Script?style=flat&color=0080ff" alt="repo-language-count">
  <img src="https://github.com/Magnetarman/Python-Script/actions/workflows/update-reqs.yml/badge.svg" alt="requirements.txt">
</p>
<p align="center">Tool e Tecnologie Utilizzate:</p>
<p align="center">
	<img src="https://img.shields.io/badge/NumPy-013243.svg?style=flat&logo=NumPy&logoColor=white" alt="NumPy">
	<img src="https://img.shields.io/badge/Python-3776AB.svg?style=flat&logo=Python&logoColor=white" alt="Python">
	<img src="https://img.shields.io/badge/GitHub%20Actions-2088FF.svg?style=flat&logo=GitHub-Actions&logoColor=white" alt="GitHub%20Actions">
	<img src="https://img.shields.io/badge/PowerShell-5391FE.svg?style=flat&logo=PowerShell&logoColor=white" alt="PowerShell">
	<img src="https://img.shields.io/badge/pandas-150458.svg?style=flat&logo=pandas&logoColor=white" alt="pandas">
</p>
<hr>

## 👾 Features

**Versione 3.0** - Nuovo approccio all'esecuzione: non si esegue più uno script isolato, ma tramite un unico punto d’ingresso interattivo.

Introdotto il file `main.py` che gestisce:

- L'installazione automatica delle dipendenze dal file `requirements.txt`.
- Un menu interattivo per scegliere quale script eseguire.
- Organizzazione automatica degli script in ordine alfabetico.
- Breve descrizione affiancata a ciascuno script.
- Migliore gestione e chiarezza degli strumenti disponibili.

---

## 📁 Struttura Cartelle

```sh
└── Python-Script/
    ├── .github
    │   └── workflows
    │       └── update-reqs.yml
    ├── LICENSE
    ├── README.md
    ├── install.ps1
    ├── main.py
	├── Docs
    ├── pipreqs-config.toml
    ├── requirements.txt
    └── scripts
        ├── audio_extract.py
        ├── codec_expoler.py
        ├── color_palette.py
        ├── efolder.py
        ├── elenco_cartelle.py
        ├── eml_converter.py
        ├── estensioni.py
        ├── image_downloader.py
        ├── png_converter.py
        ├── remove.py
        ├── sposta_file.py
        ├── transcribe_wav.py
        └── trash.py
```

### 📂 Idex Progetto

<details open>
	<summary><b><code>PYTHON-SCRIPT/</code></b></summary>
	<details> <!-- __root__ Submodule -->
		<summary><b>__root__</b></summary>
		<blockquote>
			<table>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/install.ps1'>install.ps1</a></b></td>
				<td><code>❯ Installa Python 3.10 e lancia lo script generale "main.py"</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/main.py'>main.py</a></b></td>
				<td><code>❯ Script Generale con breve descrizione degli script disponibili</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/requirements.txt'>requirements.txt</a></b></td>
				<td><code>❯ Librerie necessarie al funzionamento degli script</code></td>
			</tr>
			</table>
		</blockquote>
	</details>
		</blockquote>
	</details>
	<details> <!-- scripts Submodule -->
		<summary><b>scripts</b></summary>
		<blockquote>
			<table>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/png_converter.py'>png_converter.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/audio_extract.py'>audio_extract.py</a></b></td>
				<td><code>❯ Estrae tracce audio dai file `.mkv` (singoli o da cartelle), analizzandole con `ffprobe` e salvandole come `.flac` tramite `ffmpeg`.</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/color_palette.py'>color_palette.py</a></b></td>
				<td><code>❯ Estrazione e salvataggio dei colori in formato PDF dominanti da un'immagine.</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/transcribe_wav.py'>transcribe_wav.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/remove.py'>remove.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/efolder.py'>efolder.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/sposta_file.py'>sposta_file.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/codec_expoler.py'>codec_expoler.py</a></b></td>
				<td><code>❯ Analizza i file video identifica codec H264 o H265, ne mostra i dettagli e consente l’esportazione.</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/image_downloader.py'>image_downloader.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/eml_converter.py'>eml_converter.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/elenco_cartelle.py'>elenco_cartelle.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/trash.py'>trash.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			<tr>
				<td><b><a href='https://github.com/Magnetarman/Python-Script/blob/master/scripts/estensioni.py'>estensioni.py</a></b></td>
				<td><code>❯ REPLACE-ME</code></td>
			</tr>
			</table>
		</blockquote>
	</details>
</details>

---

## 🚀 Getting Started

### ☑️ Prerequisiti

Prima di iniziare con Python-Script, assicurati che il tuo ambiente di esecuzione soddisfi i seguenti requisiti:

- **Linguaggio di Programmazione:** Python
- **Gestore di Pacchetti:** Pip

### ⚙️ Installatione

Utilizza Python-Script seguendo questi step:

1. Clona la repository the Python-Script:

```sh
❯ git clone https://github.com/Magnetarman/Python-Script
```

2. utilizza il terminale per Navigare fino alla cartella:

```sh
❯ cd Python-Script
```

3. Lancia "main.py":

```sh
❯ py main.py
```

---

## 📌 Roadmap

- [x] **`V 3.0`**: <strike>Creazione 'main.py'.</strike>
- [ ] **`V 3.1`**: Automatizzare il processo di installazione di Python e dipendenze al 100%.
- [ ] **`V 4.0`**: unificare il tutto in un unico'main.py' con aggiunta di Interfaccia grafica.

---

## 🔰 Come Contribuire

- **💬 [Partecipa alle Discussioni](https://github.com/Magnetarman/Python-Script/discussions)**: Condividi le tue idee, fornisci feedback o fai domande.
- **🐛 [Segnala Problemi](https://github.com/Magnetarman/Python-Script/issues)**: Segnala i bug trovati o richiedi nuove funzionalità per il progetto `Python-Script`.
- **💡 [ Invia Pull Request](https://github.com/Magnetarman/Python-Script/blob/main/CONTRIBUTING.md)**: Revisiona le Pull Request (PR) aperte e invia le tue.

<details closed>
<summary>Linee Guida</summary>

1. **Esegui il Fork della Repository**: Inizia facendo il "fork" della repository del progetto sul tuo account GitHub.
2. **Clona in Locale**: Clona la repository di cui hai fatto il fork sulla tua macchina locale usando un client Git.
   ```sh
   git clone https://github.com/Magnetarman/Python-Script
   ```
3. **Crea un Nuovo Branch**: Lavora sempre su un nuovo "branch", dandogli un nome descrittivo.
   ```sh
   git checkout -b new-feature-x
   ```
4. **Apporta le Tue Modifiche**: Sviluppa e testa le tue modifiche in locale.
5. **Esegui il Commit delle Tue Modifiche**: Fai il "commit" con un messaggio chiaro che descriva i tuoi aggiornamenti.
   ```sh
   git commit -m 'Implementata nuova funzionalità x.'
   ```
6. **Esegui il Push su GitHub**: Fai il "push" delle modifiche sulla tua repository "fork".
   ```sh
   git push origin nuova-funzionalita-x
   ```
7. **nvia una Pull Request**: Crea una "Pull Request" (PR) verso la repository originale del progetto. Descrivi chiaramente le modifiche e le loro motivazioni.
8. **Revisione**: Una volta che la tua PR sarà revisionata e approvata, verrà unita ("merged") nel branch principale. Congratulazioni per il tuo contributo!
</details>

<details closed>
<summary>Contributor Graph</summary>
<br>
<p align="left">
   <a href="https://github.com{/Magnetarman/Python-Script/}graphs/contributors">
      <img src="https://contrib.rocks/image?repo=Magnetarman/Python-Script">
   </a>
</p>
</details>

---

## 🎗 Licenza

Creato con ❤️ da [Magnetarman](magnetarman.com), potenziato da ChatGPT e grazie ad [Antonio Porcelli](https://progressify.dev/) per avermi inizializzato allo scrivere e capire Python. Licenza MIT.

---

## _Trova e Cancella Cartelle Vuote_ - **efolder.py** 🗂️

Uno script Python per individuare e cancellare **cartelle vuote** all'interno di una directory specificata. Lo script esplora ricorsivamente tutte le sottocartelle e fornisce un elenco di quelle vuote, con l'opzione di eliminarle in modo sicuro.

---

### Descrizione 📄

L'**Utility Trova e Cancella Cartelle Vuote** analizza una cartella specificata dall'utente, individua tutte le cartelle vuote e chiede se eliminarle. Questo strumento è utile per:

- **Ottimizzare lo spazio** rimuovendo directory non necessarie.
- **Pulizia automatica** di cartelle generate in fase di sviluppo o backup.
- **Organizzazione** di sistemi di file complessi.

Lo script è interattivo e consente di **confermare l'eliminazione** delle cartelle vuote prima di procedere.

---

### Funzionalità 🌟

- **Scansione ricorsiva**: Esplora tutte le sottocartelle di una directory.
- **Identificazione cartelle vuote**: Elenco chiaro delle directory senza file.
- **Interattivo**: Chiede conferma prima di procedere con la cancellazione.
- **Output dettagliato**: Mostra le cartelle vuote trovate e quelle eliminate.

---

#### Esempio Input

```plaintext
Inserisci il percorso della cartella: /percorso/cartella
```

Lo script analizzerà la cartella e mostrerà tutte le cartelle vuote trovate, chiedendo se procedere con la loro eliminazione.

---

### Output 📊

#### Cartelle Trovate

```plaintext
Cartelle vuote trovate:
/percorso/cartella1
/percorso/subfolder/cartella2

Numero totale di cartelle vuote trovate: 2
```

#### Cancellazione Confermata

Se confermi l'eliminazione:

```plaintext
Cancellato: /percorso/cartella1
Cancellato: /percorso/subfolder/cartella2
```

Se scegli di non procedere:

```plaintext
Operazione annullata.
```

---

### Note 📝

- **Uso responsabile**: Verifica sempre il percorso inserito per evitare eliminazioni involontarie.
- **Sicuro**: Lo script non elimina file, solo cartelle vuote.

---

## _Elenco Cartelle di Primo Livello_ - **elenco_cartelle.py** 🗂️

Uno script Python che elenca tutte le **cartelle di primo livello** in una directory specificata dall'utente e salva i risultati in un file di testo.

---

### Descrizione 📄

L'**Elenco Cartelle di Primo Livello** esplora una directory fornita dall'utente e rileva tutte le cartelle contenute al suo interno (escludendo i file). I risultati vengono salvati automaticamente in un file **cartelle_primo_livello.txt** nella stessa directory analizzata.

Utile per:

- **Organizzare file e cartelle** in sistemi complessi.
- **Raccogliere un elenco delle sottocartelle** per analisi o report.
- **Verificare rapidamente la struttura** di una directory.

---

### Funzionalità 🌟

- **Scansione mirata**: Elenca solo le cartelle di primo livello.
- **Output organizzato**: Salva l'elenco delle cartelle in un file di testo.
- **Semplice e veloce**: Input interattivo con percorsi verificati.
- **Output sicuro**: Non modifica o elimina alcun file o cartella.

---

#### Esempio Input

```plaintext
Inserisci il percorso: /percorso/cartella
```

Lo script analizzerà il percorso inserito e salverà l'elenco delle cartelle di primo livello in un file **cartelle_primo_livello.txt**.

---

### Output 📊

#### Output Terminale

```plaintext
Risultati salvati in: /percorso/cartella/cartelle_primo_livello.txt
```

#### Contenuto del File di Output

```plaintext
Cartelle di primo livello:
/percorso/cartella1
/percorso/cartella2
/percorso/cartella3
```

Il file **cartelle_primo_livello.txt** verrà generato nella stessa cartella specificata come input.

---

### Note 📝

- **Percorsi validi**: Verifica che il percorso inserito esista e sia una directory valida.
- **Output non distruttivo**: Lo script non modifica i contenuti della directory.

---

## _Convertitore di Email in PDF 📧➡️📄_ - **eml_converter.py** 🗂️

Uno script Python per convertire file **.eml** (email salvate) in file **PDF**, mantenendo i dettagli importanti del messaggio come oggetto, mittente, destinatario e contenuto del corpo.

---

## Descrizione 📄

Questo **Convertitore di Email in PDF** esplora una cartella specificata dall'utente, trasforma i file **.eml** in HTML leggibile e poi li converte in file **PDF** salvati in una directory dedicata.

Utile per:

- **Archiviazione email** in un formato facilmente consultabile.
- **Creazione di report** PDF di comunicazioni importanti.
- **Automatizzare** il processo di conversione email in PDF.

---

## Funzionalità 🌟

- **Conversione automatica**: Legge file **.eml**, genera un HTML e lo salva come PDF.
- **Output organizzato**: Salva tutti i PDF in una cartella dedicata chiamata **converted_pdfs**.
- **Dettagli inclusi**: Oggetto, mittente, destinatario e corpo del messaggio preservati nel PDF.

---

## Requisiti 📦

- **wkhtmltopdf**: Strumento esterno necessario per generare PDF. Scaricalo e installalo dal sito ufficiale: [wkhtmltopdf.org](https://wkhtmltopdf.org/).

---

### Esempio Output

```plaintext
Inserisci il percorso della cartella contenente i file .eml: /percorso/della/cartella
Converted: email1.eml -> /percorso/della/cartella/converted_pdfs/email1.pdf
Converted: email2.eml -> /percorso/della/cartella/converted_pdfs/email2.pdf
Tutti i file .eml sono stati convertiti in PDF nella cartella 'converted_pdfs'.
```

---

## Note 📝

- **Formati supportati**: Lo script funziona con file **.eml** standard.
- **Percorsi validi**: Assicurati di fornire un percorso esistente e accessibile.
- **Output pulito**: Ogni PDF include i dettagli dell'email in un formato leggibile.

---

## _Estensioni dei File in una Cartella_ - **estensioni.py** 🗂️

Uno script Python che analizza una directory specificata dall'utente ed elenca tutte le **estensioni dei file** presenti, escludendo duplicati e organizzandole in ordine alfabetico.

---

### Descrizione 📄

L'**Estensione dei File in una Cartella** esplora una directory fornita dall'utente e rileva tutte le estensioni dei file (es. `.txt`, `.jpg`, `.pdf`). Questo strumento è utile per:

- **Organizzare** e analizzare rapidamente i tipi di file in una cartella.
- **Identificare formati presenti** per pulizie o analisi dei dati.
- **Controllare tipi di file** in sistemi di archiviazione complessi.

Lo script stampa le estensioni trovate direttamente nel terminale.

---

### Funzionalità 🌟

- **Scansione ricorsiva**: Esplora tutti i file nella cartella e sottocartelle.
- **Filtraggio intelligente**: Elimina duplicati e considera solo estensioni valide.
- **Ordinamento alfabetico**: Organizza le estensioni per una lettura chiara.
- **Semplicità d'uso**: Input interattivo e output pulito.

---

#### Esempio Input

```plaintext
Inserisci il percorso della cartella: /percorso/cartella
```

Lo script analizzerà la cartella e stamperà le estensioni dei file trovate.

---

### Output 📊

#### Output Terminale

```plaintext
Estensioni dei file trovate:
.csv
.jpg
.pdf
.png
.txt
```

Le estensioni vengono visualizzate in ordine alfabetico per una lettura chiara e organizzata.

---

### Note 📝

- **Percorsi validi**: Verifica che il percorso inserito esista e sia una directory valida.
- **Senza duplicati**: Ogni estensione viene mostrata una sola volta.
- **Ricorsivo**: Esplora anche le sottocartelle.

---

## _Scaricatore di Immagini da Pagina Web 🌐🖼️_ - **image_downloader.py** 🗂️

Uno script Python per **scaricare tutte le immagini** presenti in una pagina web, inclusi i contenuti **Base64** convertiti in PNG o nel loro formato originale.

---

## Descrizione 📄

Questo **Image Downloader** analizza il contenuto HTML di una pagina web, individua tutti i tag `<img>` e scarica le immagini collegate nel formato originale. Gestisce sia immagini con URL assoluti e relativi, sia immagini codificate in Base64.

Utile per:

- **Salvare tutte le immagini** da una pagina web con un click.
- **Effettuare scraping visivo** per archiviazione o analisi.
- **Convertire immagini Base64** in file immagine leggibili.

---

## Funzionalità 🌟

- ✅ Rileva immagini standard e in lazy loading (`src`, `data-src`).
- 🧠 Converte immagini Base64 in file reali, inclusi `.png`.
- 📁 Crea automaticamente una cartella `export` per l’output.
- 🔁 Gestisce URL relativi grazie a `urljoin`.
- 🧽 Pulisce gli URL rimuovendo parametri inutili (`?`).

---

### Esempio Output

```plaintext
Inserisci l'URL della pagina web: https://esempio.it
Scaricata: export/logo.png
Scaricata immagine Base64: export/base64_image_1.png
```

---

## Note 📝

- Le immagini SVG in Base64 vengono convertite in `.png`.
- Lo script non scarica risorse dinamiche caricate da JavaScript.
- Funziona solo con pagine accessibili pubblicamente.

---

# _Convertitore PNG in JPEG_ - **png_to_jpeg.py** 🖼️➡️🖼️

Uno script Python che converte automaticamente tutte le immagini `.png` in `.jpg` all'interno di una cartella (e sottocartelle), gestendo correttamente anche le immagini con trasparenza.

---

## Descrizione 📄

Il **Convertitore PNG in JPEG** esplora ricursivamente una cartella e converte ogni immagine `.png` in formato `.jpg`. Le immagini con trasparenza vengono adattate con sfondo bianco per mantenere la compatibilità JPEG.

Utile per:

- **Ottimizzare immagini per il web**.
- **Rimuovere trasparenze** non supportate da JPEG.
- **Convertire rapidamente** grandi quantità di immagini `.png`.

---

## Funzionalità 🌟

- **Conversione ricorsiva**: esplora tutte le sottocartelle.
- **Sfondo bianco automatico**: per PNG con trasparenza.
- **Eliminazione automatica dei PNG**: dopo la conversione, il file originale viene eliminato.
- **Log in tempo reale**: stampa in console i file convertiti e eventuali errori.

---

## Esempio di Utilizzo 🧪

### Avvia lo script:

```bash
python png_to_jpeg.py
```

### Inserisci il percorso della cartella da analizzare quando richiesto:

```plaintext
Inserisci il percorso della cartella da analizzare: /percorso/cartella
```

### Al termine, vedrai un riepilogo dei file convertiti:

```plaintext
[✔] Convertito: /img/foto1.png → /img/foto1.jpg
[✔] Convertito: /img/foto2.png → /img/foto2.jpg
```

---

## Note 📝

- Le immagini `.png` vengono eliminate dopo la conversione.
- Le immagini `.png` con trasparenza avranno sfondo bianco.
- Lo script supporta anche immagini in modalità LA, RGBA, RGB, L.

---

## _Pulizia File Non Musicali_ - **remove.py** 🗑️

Uno script Python che elimina tutti i file non musicali in una directory specificata dall'utente e rimuove eventuali cartelle vuote.

---

### Descrizione 📄

L'**Utility di Pulizia File Non Musicali** esplora una cartella e le sue sottocartelle, identificando e **rimuovendo i file non musicali** (basandosi sulle estensioni dei file). Inoltre, lo script elimina automaticamente le cartelle vuote trovate durante la scansione.

Utile per:

- **Organizzare librerie musicali** rimuovendo file indesiderati.
- **Pulire sistemi di archiviazione** mantenendo solo i file musicali.
- **Risparmiare spazio** eliminando file non necessari.

---

### Funzionalità 🌟

- **Scansione ricorsiva**: Analizza tutte le cartelle e sottocartelle.
- **Criterio intelligente**: Mantiene solo file con estensioni musicali (flac, opus, mp3, m4a, aac).
- **Rimozione sicura**: Elimina solo file non conformi e cartelle vuote.
- **Output dettagliato**: Mostra i file e le cartelle eliminate.

---

#### Esempio Input

```plaintext
Inserisci il percorso della cartella: /percorso/cartella
```

Lo script analizzerà la cartella e rimuoverà tutti i file non musicali e le cartelle vuote.

---

### Output 📊

#### Output Terminale

```plaintext
Deleting file: /percorso/cartella/file1.txt
Deleting file: /percorso/cartella/subfolder/file2.docx
Deleting empty directory: /percorso/cartella/subfolder
Pulizia completata.
```

Tutti i file non conformi vengono eliminati e il percorso è mostrato chiaramente nel terminale.

---

### Note 📝

- **Formati supportati**: Lo script conserva solo file con estensioni `.flac`, `.opus`, `.mp3`, `.m4a`, `.aac`.
- **Percorsi validi**: Verifica che il percorso inserito sia corretto e accessibile.
- **Rimozione sicura**: Le cartelle vuote vengono eliminate solo se completamente prive di contenuti.

---

## _Spostamento File nelle Directory Principali_ - **sposta_file.py** 🚚

Uno script Python che sposta tutti i file dalle sottocartelle alla **directory principale** specificata, eliminando le cartelle vuote una volta completata l'operazione.

---

### Descrizione 📄

L'**Utility di Spostamento File** esplora una directory e le sue sottocartelle, spostando **tutti i file** trovati direttamente nella cartella principale. Dopo aver spostato i file, lo script elimina automaticamente le cartelle vuote.

Utile per:

- **Organizzare** i file sparsi in sottocartelle.
- **Centralizzare i contenuti** in una cartella principale.
- **Pulire cartelle vuote** per ottimizzare la struttura dei file.

---

### Funzionalità 🌟

- **Spostamento ricorsivo**: Trova e sposta i file da tutte le sottocartelle.
- **Gestione conflitti**: Evita sovrascritture saltando i file con lo stesso nome.
- **Rimozione automatica**: Elimina le sottocartelle vuote dopo lo spostamento.
- **Output dettagliato**: Mostra i file spostati e le cartelle eliminate.

---

#### Esempio Input

```plaintext
Inserisci il percorso della directory principale: /percorso/cartella
```

Lo script analizzerà la cartella e sposterà tutti i file dalle sottocartelle alla directory principale.

---

### Output 📊

#### Output Terminale

```plaintext
Trovati 5 file da spostare.
Spostando '/percorso/cartella/subfolder/file1.txt' a '/percorso/cartella/file1.txt'
Spostando '/percorso/cartella/subfolder/file2.docx' a '/percorso/cartella/file2.docx'
Rimuovendo directory vuota '/percorso/cartella/subfolder'
3 file sono stati spostati alla directory principale.
1 sottocartelle vuote sono state rimosse.
Operazione completata.
```

---

### Note 📝

- **Conflitti di nomi**: Se un file con lo stesso nome esiste già nella directory principale, lo script salta quel file.
- **Percorsi validi**: Assicurati che il percorso inserito esista e sia accessibile.
- **Rimozione sicura**: Le cartelle vuote vengono eliminate solo se completamente prive di contenuti.

---

## _Trascrizione Automatica di Podcast_ - **transcribe_wav.py** 🎙️

Uno script Python che converte file audio in formato `.wav`, li trascrive utilizzando **Whisper** di OpenAI e salva il testo risultante in un file `.txt`.

---

### Descrizione 📄

L'**Utility di Trascrizione Podcast** esplora una cartella contenente file audio in vari formati supportati (come `.mp3`, `.flac`, `.ogg`) e:

1. **Converte i file audio** in formato `.wav` (se necessario).
2. **Trascrive il contenuto audio** utilizzando il modello di machine learning Whisper.
3. **Salva la trascrizione** in un file di testo `.txt` nella stessa cartella.

Utile per:

- **Podcaster** che vogliono generare trascrizioni automatiche dei loro contenuti.
- **Trascrizione rapida** di interviste o registrazioni audio.
- **Accessibilità** e archiviazione del contenuto audio in formato testuale.

---

### Funzionalità 🌟

- **Conversione formato**: Supporta `.mp3`, `.flac`, `.ogg` e li converte automaticamente in `.wav`.
- **Trascrizione automatica**: Utilizza il modello Whisper per trascrivere l'audio.
- **Output organizzato**: Salva le trascrizioni come file `.txt` nella stessa directory.
- **Evitare duplicati**: Salta i file già trascritti.

---

Assicurati di avere **FFmpeg** installato sul tuo sistema, necessario per pydub:

- **Windows**: Scarica FFmpeg da [ffmpeg.org](https://ffmpeg.org/)
- **Linux/Mac**: Installa con il package manager appropriato:

```bash
sudo apt install ffmpeg    # Linux
brew install ffmpeg        # MacOS
```

#### Installazione e Configurazione di FFmpeg su Windows

- **Scarica FFmpeg**:
  - Vai su [ffmpeg.org](https://ffmpeg.org/download.html).
  - Clicca su "Download" sotto "More downloading options".
  - Seleziona il link "Windows builds from gyan.dev".
  - Scarica la versione statica (ad esempio, "ffmpeg-release-essentials.zip").
- - **Estrai FFmpeg**:

    - Estrarre il file `ffmpeg-release-essentials.zip` in una directory come `C:\ffmpeg`.

- **Aggiungi FFmpeg al PATH**:
  - Apri "Impostazioni" dal menu Start.
  - Cerca "Environment Variables" e seleziona "Modifica le variabili d'ambiente di sistema".
  - Clicca su "Variabili d'ambiente" nella finestra "Proprietà del sistema".
  - Seleziona `Path` sotto "Variabili di sistema" e clicca su "Modifica...".
  - Clicca su "Nuovo" e inserisci `C:\ffmpeg\bin`.
- **Verifica l'installazione di FFmpeg**:

  - Apri il Prompt dei comandi.
  - Esegui `ffmpeg -version`.

```sh
# Crea l'ambiente virtuale
python -m venv myenv

# Attiva L'ambiente Virtuale
myenv\Scripts\activate

# Check Attivazione Ambiente Virtuale
pip install openai-whisper pydub

# Verifica l'installazione di FFmpeg
ffmpeg -version
```

---

### Esempio Input

```plaintext
Inserisci il percorso della cartella contenente i podcast: /percorso/podcast
```

Lo script analizzerà la cartella, convertirà i file non `.wav` e trascriverà il contenuto audio.

---

## Output 📊

### Output Terminale

```plaintext
Conversione di /percorso/podcast/episodio1.mp3 in formato .wav...
File convertito: /percorso/podcast/episodio1.wav
Trascrizione in corso per episodio1.wav...
Trascrizione completata per episodio1.wav, salvata in /percorso/podcast/episodio1.txt
Saltato episodio2.wav, il file di trascrizione esiste già.
```

### File di Output

Per ogni file audio, viene generato un file `.txt` con la trascrizione:

```plaintext
/percorso/podcast/episodio1.txt
/percorso/podcast/episodio2.txt
```

---

## Note 📝

- **Formati supportati**: `.mp3`, `.flac`, `.ogg`, `.wav`
- **Requisiti hardware**: La trascrizione Whisper potrebbe richiedere una GPU per performance ottimali.
- **Prevenzione duplicati**: Se un file `.txt` esiste già, lo script lo salta.

---

## _Spostamento File con Criteri di Ricerca_ - **trash.py** 🔍

Uno script Python che sposta file con nomi che terminano con uno specifico set di caratteri in una cartella dedicata chiamata **duplicati**, all'interno della stessa directory principale.

---

## Descrizione 📄

L'**Utility di Spostamento File con Criteri** esplora una cartella specificata dall'utente, cerca file i cui nomi terminano con un set di caratteri scelto dall'utente, e li sposta in una cartella **duplicati**.

Utile per:

- **Organizzare** file duplicati o con nomi specifici.
- **Raggruppare contenuti simili** in una cartella dedicata.
- **Pulizia rapida** e archiviazione automatica dei file.

---

## Funzionalità 🌟

- **Selezione dinamica**: Permette di scegliere il set di caratteri da cercare nei nomi dei file.
- **Spostamento automatico**: I file vengono spostati nella cartella **duplicati**.
- **Interfaccia interattiva**: Permette di selezionare la cartella con una finestra di dialogo.
- **Sicuro e organizzato**: Non sovrascrive i file, mantenendo un output ordinato.

---

### Esempio Input

```plaintext
Inserisci il set di caratteri che vuoi cercare alla fine dei nomi dei file: copia
```

Una volta selezionata la cartella principale, lo script analizzerà i file e sposterà quelli con nomi terminanti in "copia" nella cartella **duplicati**.

---

## Output 📊

### Output Terminale

```plaintext
File spostato in 'duplicati': /percorso/cartella/file_copia.txt
File spostato in 'duplicati': /percorso/cartella/subfolder/documento_copia.pdf
Operazione completata!
```

### Cartella di Output

I file spostati saranno salvati nella cartella:

```plaintext
/percorso/cartella/duplicati/
```

---

## Note 📝

- **Criterio di ricerca**: Cerca solo file i cui nomi terminano con il set di caratteri specificato.
- **Percorsi validi**: Assicurati di selezionare una cartella esistente.
- **Output pulito**: I file vengono spostati senza duplicare o sovrascrivere altri contenuti.

---
